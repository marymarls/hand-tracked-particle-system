<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Liquid Light Sculptor</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: #000;
        }
        #container {
            width: 100vw;
            height: 100vh;
        }
        #handOverlay {
            position: absolute;
            bottom: 20px;
            right: 20px;
            width: 400px;
            height: 300px;
            pointer-events: none;
        }
    </style>
</head>
<body>
    <button id="toggleCamera" style="position: absolute; top: 20px; right: 20px; padding: 10px 20px; background: rgba(0, 255, 136, 0.3); color: white; border: 2px solid #00ff88; border-radius: 5px; cursor: pointer; font-family: monospace; z-index: 10000;">
        Hide Camera [H]
    </button>
    <button id="startAudio" style="position: absolute; top: 80px; right: 20px; padding: 10px 20px; background: rgba(255, 100, 100, 0.3); color: white; border: 2px solid #ff6666; border-radius: 5px; cursor: pointer; font-family: monospace; z-index: 10000;">
        ðŸ”Š Start Audio
    </button>
    <div id="container"></div>
    <video id="video" style="position: absolute; bottom: 20px; right: 20px; width: 400px; height: 300px; border: 2px solid #002aff; border-radius: 10px; transform: scaleX(-1);"></video>
    <canvas id="handOverlay"></canvas>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/tone@14.8.49/build/Tone.js"></script>
    
    <script>
        // Color transition state (declare FIRST before anything uses it)
        let targetR = 0.2, targetG = 0.6, targetB = 0.9;
        let currentR = 0.2, currentG = 0.6, currentB = 0.9;

        // ===== AUDIO SYSTEM =====
        let audioStarted = false;
        let ambientSynth = null;
        let freezeSynth = null;
        let unfreezeSynth = null;

        // Initialize synths after Tone.start()
        function initAudio() {
            // Simple test synth - MUCH LOUDER
            ambientSynth = new Tone.Synth({
                volume: 0,  // Full volume!
                oscillator: { type: "sine" }
            }).toDestination();

            // Freeze sound - LOUD
            freezeSynth = new Tone.Synth({
                volume: 5,  // Very loud
                oscillator: { type: "square" }
            }).toDestination();

            // Unfreeze sound - LOUD
            unfreezeSynth = new Tone.Synth({
                volume: 5,  // Very loud
                oscillator: { type: "triangle" }
            }).toDestination();
            
            console.log("Synths initialized!");
        }

        let lastFreezeState = false;
        let lastUnfreezeTime = 0;
        // ===== AUDIO SYSTEM END =====

        // Three.js setup
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.getElementById('container').appendChild(renderer.domElement);
        camera.position.z = 10;
        
        const textureLoader = new THREE.TextureLoader();
        const particleTexture = textureLoader.load('https://threejs.org/examples/textures/sprites/disc.png');
        
        // Particle system
        const particleCount = 1000;
        const particles = new THREE.BufferGeometry();
        const positions = new Float32Array(particleCount * 3);
        const colors = new Float32Array(particleCount * 3);
        const velocities = [];
        // frozen state for each particle
        const frozenParticles = [];
        
        // Initialize particles in a sphere shape
        for (let i = 0; i < particleCount; i++) {
            const i3 = i * 3;
            const radius = Math.random() * 0.5;
            const theta = Math.random() * Math.PI * 2;
            const phi = Math.random() * Math.PI;
            
            positions[i3] = radius * Math.sin(phi) * Math.cos(theta);
            positions[i3 + 1] = radius * Math.sin(phi) * Math.sin(theta);
            positions[i3 + 2] = radius * Math.cos(phi);
            
            colors[i3] = 0.2;
            colors[i3 + 1] = 0.8;
            colors[i3 + 2] = 0.6;
            
            velocities.push(new THREE.Vector3(0, 0, 0));
            frozenParticles.push(false);  // Not frozen initially
        }
        
        particles.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        particles.setAttribute('color', new THREE.BufferAttribute(colors, 3));
        
        const particleMaterial = new THREE.PointsMaterial({
            size: 0.15,
            map: particleTexture,
            vertexColors: true,
            transparent: true,
            opacity: 1.0,
            blending: THREE.AdditiveBlending,
            depthWrite: false,
            sizeAttenuation: true
        });

        // Frozen particle material (star/diamond shapes)
        const canvas = document.createElement('canvas');
        canvas.width = 32;
        canvas.height = 32;
        const ctx = canvas.getContext('2d');

        // Draw a star shape
        ctx.fillStyle = 'white';
        ctx.beginPath();
        for (let i = 0; i < 5; i++) {
            const angle = (i * 4 * Math.PI) / 5 - Math.PI / 2;
            const x = 16 + Math.cos(angle) * 12;
            const y = 16 + Math.sin(angle) * 12;
            if (i === 0) ctx.moveTo(x, y);
            else ctx.lineTo(x, y);
        }
        ctx.closePath();
        ctx.fill();

        const starTexture = new THREE.CanvasTexture(canvas);

        const frozenMaterial = new THREE.PointsMaterial({
            size: 0.20,  // Slightly bigger
            map: starTexture,
            vertexColors: true,
            transparent: true,
            opacity: 1.0,
            blending: THREE.AdditiveBlending,
            depthWrite: false,
            sizeAttenuation: true
        });
        
        // Create two particle systems - one for normal, one for frozen
        const normalParticleSystem = new THREE.Points(particles, particleMaterial);
        const frozenParticleSystem = new THREE.Points(particles, frozenMaterial);
        scene.add(normalParticleSystem);
        scene.add(frozenParticleSystem);
        
        // Create lines that connect nearby particles
        const maxConnections = 3000;
        const linePositions = new Float32Array(maxConnections * 3 * 2);
        const lineGeometry = new THREE.BufferGeometry();
        lineGeometry.setAttribute('position', new THREE.BufferAttribute(linePositions, 3));

        const lineMaterial = new THREE.LineBasicMaterial({
            color: 0x00ff88,
            transparent: true,
            opacity: 0.3,
            blending: THREE.AdditiveBlending
        });

        const lineSegments = new THREE.LineSegments(lineGeometry, lineMaterial);
        scene.add(lineSegments);

        // Create FROZEN particle energy field lines (brighter, different color)
        const frozenLineGeometry = new THREE.BufferGeometry();
        const maxFrozenConnections = 1000;
        const frozenLinePositions = new Float32Array(maxFrozenConnections * 3 * 2);
        frozenLineGeometry.setAttribute('position', new THREE.BufferAttribute(frozenLinePositions, 3));

        const frozenLineMaterial = new THREE.LineBasicMaterial({
            color: 0xffffff,  // Bright white for frozen
            transparent: true,
            opacity: 0.8,  // Much brighter than normal connections
            blending: THREE.AdditiveBlending
        });

        const frozenLineSegments = new THREE.LineSegments(frozenLineGeometry, frozenLineMaterial);
        scene.add(frozenLineSegments);

        // ===== TRAIL SYSTEM START =====
        const maxTrailPoints = 500;
        const trailPositions = new Float32Array(maxTrailPoints * 3);
        const trailColors = new Float32Array(maxTrailPoints * 3);
        const trailLifetimes = new Float32Array(maxTrailPoints);

        for (let i = 0; i < maxTrailPoints; i++) {
            trailLifetimes[i] = 0;
        }

        const trailGeometry = new THREE.BufferGeometry();
        trailGeometry.setAttribute('position', new THREE.BufferAttribute(trailPositions, 3));
        trailGeometry.setAttribute('color', new THREE.BufferAttribute(trailColors, 3));

        const trailMaterial = new THREE.PointsMaterial({
            size: 0.20,
            vertexColors: true,
            transparent: true,
            opacity: 0.6,
            blending: THREE.AdditiveBlending,
            depthWrite: false
        });

        const trailSystem = new THREE.Points(trailGeometry, trailMaterial);
        scene.add(trailSystem);
        // ===== TRAIL SYSTEM END =====
        
        // Hand position indicators
        const boxGeometry = new THREE.BoxGeometry(0.3, 0.3, 0.3);

        const leftIndicator = new THREE.Mesh(
            boxGeometry,
            new THREE.MeshBasicMaterial({ 
                color: 0xffffff, 
                wireframe: true,
                transparent: true,
                opacity: 0.9
            })
        );
        leftIndicator.visible = false;
        scene.add(leftIndicator);

        const rightIndicator = new THREE.Mesh(
            boxGeometry,
            new THREE.MeshBasicMaterial({ 
                color: 0xffffff, 
                wireframe: true,
                transparent: true,
                opacity: 0.9
            })
        );
        rightIndicator.visible = false;
        scene.add(rightIndicator);
        
        // Hand tracking variables
        let leftHand = null;
        let rightHand = null;
        
        // Initialize MediaPipe Hands
        const hands = new Hands({
            locateFile: (file) => {
                return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
            }
        });
        
        hands.setOptions({
            maxNumHands: 2,
            modelComplexity: 1,
            minDetectionConfidence: 0.5,
            minTrackingConfidence: 0.5
        });
        
        hands.onResults((results) => {
            overlayCtx.clearRect(0, 0, overlayCanvas.width, overlayCanvas.height);
            leftHand = null;
            rightHand = null;

            if (!results.multiHandLandmarks || !results.multiHandedness) return;

            for (let i = 0; i < results.multiHandLandmarks.length; i++) {
                const hand = results.multiHandLandmarks[i];
                const handedness = results.multiHandedness[i].label;

                if (handedness === 'Left') leftHand = hand;
                if (handedness === 'Right') rightHand = hand;

                hand.forEach(landmark => {
                    const x = (1 - landmark.x) * overlayCanvas.width;
                    const y = landmark.y * overlayCanvas.height;
                    const size = 6;

                    overlayCtx.fillStyle = 'white';
                    overlayCtx.fillRect(x - size / 2, y - size / 2, size, size);
                });
            }
        });
        
        // Setup camera
        const videoElement = document.getElementById('video');
        const overlayCanvas = document.getElementById('handOverlay');
        const overlayCtx = overlayCanvas.getContext('2d');
        overlayCanvas.width = 400;
        overlayCanvas.height = 300;

        const cameraSetup = new Camera(videoElement, {
            onFrame: async () => {
                await hands.send({ image: videoElement });
            },
            width: 1280,
            height: 720
        });
        cameraSetup.start();
        
        // Helper function
        function handToWorld(landmark) {
            return new THREE.Vector3(
                -(landmark.x - 0.5) * 12,
                -(landmark.y - 0.5) * 12,
                -landmark.z * 6
            );
        }

        // Detect if thumb and index finger are pinched together
        function isPinching(hand) {
            if (!hand) return false;
            
            const thumb = hand[4];  // Thumb tip
            const index = hand[8];  // Index tip
            
            const dx = thumb.x - index.x;
            const dy = thumb.y - index.y;
            const dz = thumb.z - index.z;
            const distance = Math.sqrt(dx * dx + dy * dy + dz * dz);
            
            return distance < 0.05;  // Pinched if fingers are close
        }
        
        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            
            const positions = particles.attributes.position.array;
            const colors = particles.attributes.color.array;
            
            const influenceRadius = 5.0;
            const pushStrength = 0.8;

            // LEFT HAND: Unfreeze all if palm is open wide
            if (leftHand) {
                // Check if hand is open (measure distance between thumb and pinky)
                const thumb = leftHand[4];
                const pinky = leftHand[20];
                const dx = thumb.x - pinky.x;
                const dy = thumb.y - pinky.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                // If hand is wide open (distance > 0.15), unfreeze everything
                if (distance > 0.15) {
                    for (let i = 0; i < particleCount; i++) {
                        frozenParticles[i] = false;
                    }
                }
            }

            // LEFT HAND: Calculate color ONCE before loop
            let baseR = 0.2;
            let baseG = 0.6;
            let baseB = 0.9;

            if (leftHand && leftHand[8]) {
                const leftY = leftHand[8].y;
                console.log("Left Y:", leftY);
                
                if (leftY < 0.33) {
                    baseR = 0.9;
                    baseG = 0.5;
                    baseB = 0.2;
                    console.log("WARM");
                } else if (leftY < 0.66) {
                    baseR = 0.2;
                    baseG = 0.8;
                    baseB = 0.6;
                    console.log("CYAN");
                } else {
                    baseR = 0.4;
                    baseG = 0.2;
                    baseB = 0.9;
                    console.log("COOL");
                }
            }

            // Update each particle
            for (let i = 0; i < particleCount; i++) {
                const i3 = i * 3;
                const particle = new THREE.Vector3(positions[i3], positions[i3 + 1], positions[i3 + 2]);
                
                // RIGHT HAND: Movement OR Freeze
                if (rightHand) {
                    const rightIndex = handToWorld(rightHand[8]);
                    const distToRight = particle.distanceTo(rightIndex);
                    const isPinched = isPinching(rightHand);
                    
                    if (distToRight < influenceRadius) {
                        if (isPinched) {
                            // PINCH = FREEZE particles nearby
                            frozenParticles[i] = true;
                            // Stop all movement
                            velocities[i].set(0, 0, 0);
                        } else {
                            // OPEN HAND = ATTRACT particles (normal movement)
                            if (!frozenParticles[i]) {  // Only move if not frozen
                                const strength = 1 - (distToRight / influenceRadius);
                                const direction = rightIndex.clone().sub(particle).normalize();
                                const force = direction.multiplyScalar(pushStrength * strength * 0.5);
                                velocities[i].add(force);
                            }
                        }
                    }
                }
                
                // Apply velocity ONLY if not frozen
                if (!frozenParticles[i]) {
                    positions[i3] += velocities[i].x;
                    positions[i3 + 1] += velocities[i].y;
                    positions[i3 + 2] += velocities[i].z;
                }
                
                // Gentle pull back to center ONLY if not frozen
                if (!frozenParticles[i]) {
                    const centerPull = 0.0005;
                    const distanceFromCenter = Math.sqrt(
                        positions[i3] * positions[i3] + 
                        positions[i3 + 1] * positions[i3 + 1] + 
                        positions[i3 + 2] * positions[i3 + 2]
                    );
                    
                    if (distanceFromCenter > 0.1) {
                        velocities[i].x -= positions[i3] * centerPull;
                        velocities[i].y -= positions[i3 + 1] * centerPull;
                        velocities[i].z -= positions[i3 + 2] * centerPull;
                    }
                    
                    // Add damping
                    velocities[i].multiplyScalar(0.88);
                }
                
                // Set color from left hand
                colors[i3] = baseR;
                colors[i3 + 1] = baseG;
                colors[i3 + 2] = baseB;

                // Frozen particles glow white
                if (frozenParticles[i]) {
                    colors[i3] = 1.0;
                    colors[i3 + 1] = 1.0;
                    colors[i3 + 2] = 1.0;
                }

                // Vary particle brightness based on depth (Z position)
                const depthFactor = Math.max(0.3, Math.min(1, 1 - positions[i3 + 2] / 10));
                colors[i3] *= depthFactor;
                colors[i3 + 1] *= depthFactor;
                colors[i3 + 2] *= depthFactor;
            }
            
            // ===== SOUND EFFECTS =====
            if (audioStarted) {
                // Check if any particles are frozen
                const anyFrozen = frozenParticles.some(f => f);
                
                // Freeze sound (when first particle freezes)
                if (anyFrozen && !lastFreezeState) {
                    freezeSynth.triggerAttackRelease("C2", "32n");
                    lastFreezeState = true;
                }
                
                // Unfreeze sound (when all particles unfreeze)
                if (!anyFrozen && lastFreezeState) {
                    const now = Tone.now();
                    if (now - lastUnfreezeTime > 0.5) {  // Prevent rapid repeating
                        unfreezeSynth.triggerAttackRelease("C5", "16n");
                        lastUnfreezeTime = now;
                    }
                    lastFreezeState = false;
                }
                
                // Change ambient drone pitch based on color
                const noteMap = {
                    warm: ["C2", "E2", "G2"],      // Red/Orange
                    cyan: ["D2", "F#2", "A2"],     // Cyan/Green
                    cool: ["Eb2", "G2", "Bb2"]     // Blue/Purple
                };
                
                let currentNotes = noteMap.cyan;
                if (targetR > 0.7) currentNotes = noteMap.warm;
                else if (targetB > 0.7) currentNotes = noteMap.cool;
                
                // Smoothly transition ambient notes
                // (This is simplified - full implementation would use Tone.js scheduling)
            }
            // ===== SOUND EFFECTS END =====

            // Update hand indicators
            if (leftHand) {
                const leftPos = handToWorld(leftHand[8]);
                leftIndicator.position.copy(leftPos);
                leftIndicator.visible = true;
                leftIndicator.rotation.x += 0.02;
                leftIndicator.rotation.y += 0.02;
            } else {
                leftIndicator.visible = false;
            }

            if (rightHand) {
                const rightPos = handToWorld(rightHand[8]);
                rightIndicator.position.copy(rightPos);
                rightIndicator.visible = true;
                rightIndicator.rotation.x += 0.02;
                rightIndicator.rotation.y += 0.02;
            } else {
                rightIndicator.visible = false;
            }

            // ===== TRAIL RECORDING START =====
            if (rightHand && !isPinching(rightHand)) {
                const rightPos = handToWorld(rightHand[8]);
                
                // Shift all trail points back
                for (let i = maxTrailPoints - 1; i > 0; i--) {
                    const currIdx = i * 3;
                    const prevIdx = (i - 1) * 3;
                    
                    trailPositions[currIdx] = trailPositions[prevIdx];
                    trailPositions[currIdx + 1] = trailPositions[prevIdx + 1];
                    trailPositions[currIdx + 2] = trailPositions[prevIdx + 2];
                    
                    trailColors[currIdx] = trailColors[prevIdx];
                    trailColors[currIdx + 1] = trailColors[prevIdx + 1];
                    trailColors[currIdx + 2] = trailColors[prevIdx + 2];
                    
                    trailLifetimes[i] = trailLifetimes[i - 1];
                }
                
                // Add new trail point
                trailPositions[0] = rightPos.x;
                trailPositions[1] = rightPos.y;
                trailPositions[2] = rightPos.z;
                
                trailColors[0] = currentR;
                trailColors[1] = currentG;
                trailColors[2] = currentB;
                
                trailLifetimes[0] = 1.0;
            }

            // Fade trails over time
            for (let i = 0; i < maxTrailPoints; i++) {
                if (trailLifetimes[i] > 0) {
                    const i3 = i * 3;
                    const fade = Math.max(0, trailLifetimes[i]);
                    trailColors[i3] = currentR * fade;
                    trailColors[i3 + 1] = currentG * fade;
                    trailColors[i3 + 2] = currentB * fade;
                    trailLifetimes[i] -= 0.01;
                }
            }

            trailGeometry.attributes.position.needsUpdate = true;
            trailGeometry.attributes.color.needsUpdate = true;
            // ===== TRAIL RECORDING END =====
            
            // FROZEN PARTICLE ENERGY FIELDS (bright connections)
            const frozenConnectionDistance = 2.0;
            let frozenConnectionCount = 0;

            for (let i = 0; i < particleCount && frozenConnectionCount < maxFrozenConnections; i++) {
                if (!frozenParticles[i]) continue;
                
                const i3 = i * 3;
                const px = positions[i3];
                const py = positions[i3 + 1];
                const pz = positions[i3 + 2];
                
                for (let j = i + 1; j < particleCount && frozenConnectionCount < maxFrozenConnections; j++) {
                    if (!frozenParticles[j]) continue;
                    
                    const j3 = j * 3;
                    const dx = px - positions[j3];
                    const dy = py - positions[j3 + 1];
                    const dz = pz - positions[j3 + 2];
                    const distance = Math.sqrt(dx * dx + dy * dy + dz * dz);
                    
                    if (distance < frozenConnectionDistance) {
                        const lineIndex = frozenConnectionCount * 6;
                        frozenLinePositions[lineIndex] = px;
                        frozenLinePositions[lineIndex + 1] = py;
                        frozenLinePositions[lineIndex + 2] = pz;
                        frozenLinePositions[lineIndex + 3] = positions[j3];
                        frozenLinePositions[lineIndex + 4] = positions[j3 + 1];
                        frozenLinePositions[lineIndex + 5] = positions[j3 + 2];
                        frozenConnectionCount++;
                    }
                }
            }

            frozenLineGeometry.setDrawRange(0, frozenConnectionCount * 2);
            frozenLineGeometry.attributes.position.needsUpdate = true;

            // Update liquid connections
            const connectionDistance = 0.5;
            let connectionCount = 0;

            for (let i = 0; i < particleCount && connectionCount < maxConnections; i++) {
                const i3 = i * 3;
                const px = positions[i3];
                const py = positions[i3 + 1];
                const pz = positions[i3 + 2];
                
                for (let j = i + 1; j < particleCount && connectionCount < maxConnections; j++) {
                    const j3 = j * 3;
                    const dx = px - positions[j3];
                    const dy = py - positions[j3 + 1];
                    const dz = pz - positions[j3 + 2];
                    const distance = Math.sqrt(dx * dx + dy * dy + dz * dz);
                    
                    if (distance < connectionDistance) {
                        const lineIndex = connectionCount * 6;
                        linePositions[lineIndex] = px;
                        linePositions[lineIndex + 1] = py;
                        linePositions[lineIndex + 2] = pz;
                        linePositions[lineIndex + 3] = positions[j3];
                        linePositions[lineIndex + 4] = positions[j3 + 1];
                        linePositions[lineIndex + 5] = positions[j3 + 2];
                        connectionCount++;
                    }
                }
            }

            lineGeometry.setDrawRange(0, connectionCount * 2);
            lineGeometry.attributes.position.needsUpdate = true;
            particles.attributes.position.needsUpdate = true;
            particles.attributes.color.needsUpdate = true;
            
            // Update which particles are visible in each system
            const normalIndices = [];
            const frozenIndices = [];

            for (let i = 0; i < particleCount; i++) {
                if (frozenParticles[i]) {
                    frozenIndices.push(i);
                } else {
                    normalIndices.push(i);
                }
            }

            renderer.render(scene, camera);
        }
        
        animate();
        
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
        
        // Toggle camera
        const toggleBtn = document.getElementById('toggleCamera');
        const video = document.getElementById('video');
        const overlay = document.getElementById('handOverlay');
        let cameraVisible = true;

        function toggleCamera() {
            cameraVisible = !cameraVisible;
            video.style.display = cameraVisible ? 'block' : 'none';
            overlay.style.display = cameraVisible ? 'block' : 'none';
            toggleBtn.textContent = cameraVisible ? 'Hide Camera [H]' : 'Show Camera [H]';
        }

        toggleBtn.addEventListener('click', toggleCamera);
        window.addEventListener('keydown', (e) => {
            if (e.key === 'h' || e.key === 'H') toggleCamera();
        });

        // Start audio system
        const startAudioBtn = document.getElementById('startAudio');
        startAudioBtn.addEventListener('click', async () => {
            if (!audioStarted) {
                await Tone.start();
                audioStarted = true;
                
                // Initialize synths AFTER Tone.start()
                initAudio();
                
                // Start ambient drone
                ambientSynth.triggerAttack(["C2", "E2", "G2"]);
                
                startAudioBtn.textContent = "ðŸ”Š Audio On";
                startAudioBtn.style.background = "rgba(100, 255, 100, 0.3)";
                startAudioBtn.style.borderColor = "#66ff66";
                
                console.log("Audio started!");
            }
        });
    </script>
</body>
</html>