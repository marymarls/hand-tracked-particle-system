<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Liquid Light Sculptor</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: #000;
        }
        #container {
            width: 100vw;
            height: 100vh;
        }
        #handOverlay {
            position: absolute;
            bottom: 20px;
            right: 20px;
            width: 400px;
            height: 300px;
            pointer-events: none;
        }
    </style>
</head>
<body>
    <button id="toggleCamera" style="position: absolute; top: 20px; right: 20px; padding: 10px 20px; background: rgba(0, 255, 136, 0.3); color: white; border: 2px solid #00ff88; border-radius: 5px; cursor: pointer; font-family: monospace; z-index: 10000;">
        Hide Camera [H]
    </button>
    <div id="container"></div>
    <video id="video" style="position: absolute; bottom: 20px; right: 20px; width: 400px; height: 300px; border: 2px solid #002aff; border-radius: 10px; transform: scaleX(-1);"></video>
    <canvas id="handOverlay"></canvas>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
    
    <script>
        // Color transition state (declare FIRST before anything uses it)
        let targetR = 0.2, targetG = 0.6, targetB = 0.9;
        let currentR = 0.2, currentG = 0.6, currentB = 0.9;

        // Three.js setup
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.getElementById('container').appendChild(renderer.domElement);
        camera.position.z = 10;
        
        const textureLoader = new THREE.TextureLoader();
        const particleTexture = textureLoader.load('https://threejs.org/examples/textures/sprites/disc.png');
        
        // Particle system
        const particleCount = 1000;
        const particles = new THREE.BufferGeometry();
        const positions = new Float32Array(particleCount * 3);
        const colors = new Float32Array(particleCount * 3);
        const velocities = [];
        
        // Initialize particles in a sphere shape
        for (let i = 0; i < particleCount; i++) {
            const i3 = i * 3;
            const radius = Math.random() * 0.5;
            const theta = Math.random() * Math.PI * 2;
            const phi = Math.random() * Math.PI;
            
            positions[i3] = radius * Math.sin(phi) * Math.cos(theta);
            positions[i3 + 1] = radius * Math.sin(phi) * Math.sin(theta);
            positions[i3 + 2] = radius * Math.cos(phi);
            
            colors[i3] = 0.2;
            colors[i3 + 1] = 0.8;
            colors[i3 + 2] = 0.6;
            
            velocities.push(new THREE.Vector3(0, 0, 0));
        }
        
        particles.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        particles.setAttribute('color', new THREE.BufferAttribute(colors, 3));
        
        const particleMaterial = new THREE.PointsMaterial({
            size: 0.12,
            map: particleTexture,
            vertexColors: true,
            transparent: true,
            opacity: 0.9,
            blending: THREE.AdditiveBlending,
            depthWrite: false,
            sizeAttenuation: true
        });
        
        const particleSystem = new THREE.Points(particles, particleMaterial);
        scene.add(particleSystem);
        
        // Create lines that connect nearby particles
        const maxConnections = 3000;
        const linePositions = new Float32Array(maxConnections * 3 * 2);
        const lineGeometry = new THREE.BufferGeometry();
        lineGeometry.setAttribute('position', new THREE.BufferAttribute(linePositions, 3));

        const lineMaterial = new THREE.LineBasicMaterial({
            color: 0x00ff88,
            transparent: true,
            opacity: 0.3,
            blending: THREE.AdditiveBlending
        });

        const lineSegments = new THREE.LineSegments(lineGeometry, lineMaterial);
        scene.add(lineSegments);
        
        // Hand position indicators
        const boxGeometry = new THREE.BoxGeometry(0.3, 0.3, 0.3);

        const leftIndicator = new THREE.Mesh(
            boxGeometry,
            new THREE.MeshBasicMaterial({ 
                color: 0xffffff, 
                wireframe: true,
                transparent: true,
                opacity: 0.9
            })
        );
        leftIndicator.visible = false;
        scene.add(leftIndicator);

        const rightIndicator = new THREE.Mesh(
            boxGeometry,
            new THREE.MeshBasicMaterial({ 
                color: 0xffffff, 
                wireframe: true,
                transparent: true,
                opacity: 0.9
            })
        );
        rightIndicator.visible = false;
        scene.add(rightIndicator);
        
        // Hand tracking variables
        let leftHand = null;
        let rightHand = null;
        
        // Initialize MediaPipe Hands
        const hands = new Hands({
            locateFile: (file) => {
                return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
            }
        });
        
        hands.setOptions({
            maxNumHands: 2,
            modelComplexity: 1,
            minDetectionConfidence: 0.5,
            minTrackingConfidence: 0.5
        });
        
        hands.onResults((results) => {
            overlayCtx.clearRect(0, 0, overlayCanvas.width, overlayCanvas.height);
            leftHand = null;
            rightHand = null;

            if (!results.multiHandLandmarks || !results.multiHandedness) return;

            for (let i = 0; i < results.multiHandLandmarks.length; i++) {
                const hand = results.multiHandLandmarks[i];
                const handedness = results.multiHandedness[i].label;

                if (handedness === 'Left') leftHand = hand;
                if (handedness === 'Right') rightHand = hand;

                hand.forEach(landmark => {
                    const x = (1 - landmark.x) * overlayCanvas.width;
                    const y = landmark.y * overlayCanvas.height;
                    const size = 6;

                    overlayCtx.fillStyle = 'white';
                    overlayCtx.fillRect(x - size / 2, y - size / 2, size, size);
                });
            }
        });
        
        // Setup camera
        const videoElement = document.getElementById('video');
        const overlayCanvas = document.getElementById('handOverlay');
        const overlayCtx = overlayCanvas.getContext('2d');
        overlayCanvas.width = 400;
        overlayCanvas.height = 300;

        const cameraSetup = new Camera(videoElement, {
            onFrame: async () => {
                await hands.send({ image: videoElement });
            },
            width: 1280,
            height: 720
        });
        cameraSetup.start();
        
        // Helper function
        function handToWorld(landmark) {
            return new THREE.Vector3(
                -(landmark.x - 0.5) * 12,
                -(landmark.y - 0.5) * 12,
                -landmark.z * 6
            );
        }
        
        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            
            const positions = particles.attributes.position.array;
            const colors = particles.attributes.color.array;
            
            const influenceRadius = 5.0;
            const pushStrength = 0.8;

            // LEFT HAND: Calculate color ONCE before loop
            let baseR = 0.2;
            let baseG = 0.6;
            let baseB = 0.9;

            if (leftHand && leftHand[8]) {
                const leftY = leftHand[8].y;
                console.log("Left Y:", leftY);
                
                if (leftY < 0.33) {
                    baseR = 0.9;
                    baseG = 0.5;
                    baseB = 0.2;
                    console.log("WARM");
                } else if (leftY < 0.66) {
                    baseR = 0.2;
                    baseG = 0.8;
                    baseB = 0.6;
                    console.log("CYAN");
                } else {
                    baseR = 0.4;
                    baseG = 0.2;
                    baseB = 0.9;
                    console.log("COOL");
                }
            }

            // Update each particle
            for (let i = 0; i < particleCount; i++) {
                const i3 = i * 3;
                const particle = new THREE.Vector3(positions[i3], positions[i3 + 1], positions[i3 + 2]);
                
                // RIGHT HAND ONLY: Movement
                if (rightHand) {
                    const rightIndex = handToWorld(rightHand[8]);
                    const distToRight = particle.distanceTo(rightIndex);
                    
                    if (distToRight < influenceRadius) {
                        const strength = 1 - (distToRight / influenceRadius);
                        const direction = rightIndex.clone().sub(particle).normalize();
                        const force = direction.multiplyScalar(pushStrength * strength * 0.5);
                        velocities[i].add(force);
                    }
                }
                
                // Apply velocity
                positions[i3] += velocities[i].x;
                positions[i3 + 1] += velocities[i].y;
                positions[i3 + 2] += velocities[i].z;
                
                // Gentle pull back to center
                const centerPull = 0.0005;
                const distanceFromCenter = Math.sqrt(
                    positions[i3] * positions[i3] + 
                    positions[i3 + 1] * positions[i3 + 1] + 
                    positions[i3 + 2] * positions[i3 + 2]
                );
                
                if (distanceFromCenter > 0.1) {
                    velocities[i].x -= positions[i3] * centerPull;
                    velocities[i].y -= positions[i3 + 1] * centerPull;
                    velocities[i].z -= positions[i3 + 2] * centerPull;
                }
                
                // Add damping
                velocities[i].multiplyScalar(0.88);
                
                // Set color from left hand
                colors[i3] = baseR;
                colors[i3 + 1] = baseG;
                colors[i3 + 2] = baseB;
            }
            
            // Update hand indicators
            if (leftHand) {
                const leftPos = handToWorld(leftHand[8]);
                leftIndicator.position.copy(leftPos);
                leftIndicator.visible = true;
                leftIndicator.rotation.x += 0.02;
                leftIndicator.rotation.y += 0.02;
            } else {
                leftIndicator.visible = false;
            }

            if (rightHand) {
                const rightPos = handToWorld(rightHand[8]);
                rightIndicator.position.copy(rightPos);
                rightIndicator.visible = true;
                rightIndicator.rotation.x += 0.02;
                rightIndicator.rotation.y += 0.02;
            } else {
                rightIndicator.visible = false;
            }
            
            // Update liquid connections
            const connectionDistance = 0.5;
            let connectionCount = 0;

            for (let i = 0; i < particleCount && connectionCount < maxConnections; i++) {
                const i3 = i * 3;
                const px = positions[i3];
                const py = positions[i3 + 1];
                const pz = positions[i3 + 2];
                
                for (let j = i + 1; j < particleCount && connectionCount < maxConnections; j++) {
                    const j3 = j * 3;
                    const dx = px - positions[j3];
                    const dy = py - positions[j3 + 1];
                    const dz = pz - positions[j3 + 2];
                    const distance = Math.sqrt(dx * dx + dy * dy + dz * dz);
                    
                    if (distance < connectionDistance) {
                        const lineIndex = connectionCount * 6;
                        linePositions[lineIndex] = px;
                        linePositions[lineIndex + 1] = py;
                        linePositions[lineIndex + 2] = pz;
                        linePositions[lineIndex + 3] = positions[j3];
                        linePositions[lineIndex + 4] = positions[j3 + 1];
                        linePositions[lineIndex + 5] = positions[j3 + 2];
                        connectionCount++;
                    }
                }
            }

            lineGeometry.setDrawRange(0, connectionCount * 2);
            lineGeometry.attributes.position.needsUpdate = true;
            particles.attributes.position.needsUpdate = true;
            particles.attributes.color.needsUpdate = true;
            
            renderer.render(scene, camera);
        }
        
        animate();
        
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
        
        // Toggle camera
        const toggleBtn = document.getElementById('toggleCamera');
        const video = document.getElementById('video');
        const overlay = document.getElementById('handOverlay');
        let cameraVisible = true;

        function toggleCamera() {
            cameraVisible = !cameraVisible;
            video.style.display = cameraVisible ? 'block' : 'none';
            overlay.style.display = cameraVisible ? 'block' : 'none';
            toggleBtn.textContent = cameraVisible ? 'Hide Camera [H]' : 'Show Camera [H]';
        }

        toggleBtn.addEventListener('click', toggleCamera);
        window.addEventListener('keydown', (e) => {
            if (e.key === 'h' || e.key === 'H') toggleCamera();
        });
    </script>
</body>
</html>