<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Liquid Light Sculptor</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: #000;
        }
        #container {
            width: 100vw;
            height: 100vh;
        }
        #handOverlay {
            position: absolute;
            bottom: 20px;
            right: 20px;
            width: 400px;
            height: 300px;
            pointer-events: none;
        }
    </style>
</head>
<body>
    <button id="toggleCamera" style="position: absolute; top: 20px; right: 20px; padding: 10px 20px; background: rgba(0, 255, 136, 0.3); color: white; border: 2px solid #00ff88; border-radius: 5px; cursor: pointer; font-family: monospace; z-index: 1000;">
        Hide Camera [H]
    </button>
    <div id="colorIndicator" style="position: absolute; top: 80px; right: 20px; width: 40px; height: 200px; border: 2px solid white; border-radius: 10px; background: linear-gradient(to bottom, #ff6b35, #00ff88, #6b5bff); opacity: 0.5; z-index: 1000;"></div>
    <div id="colorMarker" style="position: absolute; top: 80px; right: 15px; width: 50px; height: 4px; background: white; border-radius: 2px; display: none; z-index: 1001; box-shadow: 0 0 10px white;"></div>
    <div id="container"></div>
    <video id="video" style="position: absolute; bottom: 20px; right: 20px; width: 400px; height: 300px; border: 2px solid #002aff; border-radius: 10px; transform: scaleX(-1);"></video>
    <canvas id="handOverlay"></canvas>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
    
    <script>
        // Three.js setup
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.getElementById('container').appendChild(renderer.domElement);
        camera.position.z = 10;
        const textureLoader = new THREE.TextureLoader();
        const particleTexture = textureLoader.load(
        'https://threejs.org/examples/textures/sprites/disc.png'
        );
        
        // Particle system
        const particleCount = 1000;
        const particles = new THREE.BufferGeometry();
        const positions = new Float32Array(particleCount * 3);
        const colors = new Float32Array(particleCount * 3);
        const velocities = [];
        
        // Initialize particles in a sphere shape
        for (let i = 0; i < particleCount; i++) {
            const i3 = i * 3;
            const radius = Math.random() * 0.5;
            const theta = Math.random() * Math.PI * 2;
            const phi = Math.random() * Math.PI;
            
            positions[i3] = radius * Math.sin(phi) * Math.cos(theta);
            positions[i3 + 1] = radius * Math.sin(phi) * Math.sin(theta);
            positions[i3 + 2] = radius * Math.cos(phi);
            
            colors[i3] = 0.2;
            colors[i3 + 1] = 0.8;
            colors[i3 + 2] = 0.6;
            
            velocities.push(new THREE.Vector3(0, 0, 0));
        }
        
        particles.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        particles.setAttribute('color', new THREE.BufferAttribute(colors, 3));
        
        const particleMaterial = new THREE.PointsMaterial({
            size: 0.12,
            map: particleTexture,
            vertexColors: true,
            transparent: true,
            opacity: 0.9,
            blending: THREE.AdditiveBlending,
            depthWrite: false,
            sizeAttenuation: true
        });
        
        const particleSystem = new THREE.Points(particles, particleMaterial);
        scene.add(particleSystem);
        
        // Create lines that connect nearby particles (liquid effect)
        const maxConnections = 3000;
        const linePositions = new Float32Array(maxConnections * 3 * 2);
        const lineGeometry = new THREE.BufferGeometry();
        lineGeometry.setAttribute('position', new THREE.BufferAttribute(linePositions, 3));

        const lineMaterial = new THREE.LineBasicMaterial({
            color: 0x00ff88,
            transparent: true,
            opacity: 0.3,
            blending: THREE.AdditiveBlending
        });

        const lineSegments = new THREE.LineSegments(lineGeometry, lineMaterial);
        scene.add(lineSegments);
        
        // Hand position indicators - WHITE WIREFRAME BOXES
        const boxGeometry = new THREE.BoxGeometry(0.3, 0.3, 0.3);

        const leftIndicator = new THREE.Mesh(
            boxGeometry,
            new THREE.MeshBasicMaterial({ 
                color: 0xffffff, 
                wireframe: true,
                transparent: true,
                opacity: 0.9
            })
        );
        leftIndicator.visible = false;
        scene.add(leftIndicator);

        const rightIndicator = new THREE.Mesh(
            boxGeometry,
            new THREE.MeshBasicMaterial({ 
                color: 0xffffff, 
                wireframe: true,
                transparent: true,
                opacity: 0.9
            })
        );
        rightIndicator.visible = false;
        scene.add(rightIndicator);
        
        // Hand tracking variables
        let leftHand = null;
        let rightHand = null;
        
        // Initialize MediaPipe Hands
        const hands = new Hands({
            locateFile: (file) => {
                return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
            }
        });
        
        hands.setOptions({
            maxNumHands: 2,
            modelComplexity: 1,
            minDetectionConfidence: 0.5,
            minTrackingConfidence: 0.5
        });
        
        hands.onResults((results) => {
            // Clear 2D overlay
            overlayCtx.clearRect(0, 0, overlayCanvas.width, overlayCanvas.height);

            // Reset hands
            leftHand = null;
            rightHand = null;

            if (!results.multiHandLandmarks || !results.multiHandedness) return;

            // Loop through detected hands
            for (let i = 0; i < results.multiHandLandmarks.length; i++) {
                const hand = results.multiHandLandmarks[i];
                const handedness = results.multiHandedness[i].label;

                // Assign left / right hand for 3D interaction
                if (handedness === 'Left') leftHand = hand;
                if (handedness === 'Right') rightHand = hand;

                // Draw white squares on landmarks (camera overlay)
                hand.forEach(landmark => {
                    const x = (1 - landmark.x) * overlayCanvas.width;
                    const y = landmark.y * overlayCanvas.height;

                    const size = 6;

                    overlayCtx.fillStyle = 'white';
                    overlayCtx.fillRect(
                        x - size / 2,
                        y - size / 2,
                        size,
                        size
                    );
                });
            }
        });

        
        // Setup camera
        const videoElement = document.getElementById('video');
        const overlayCanvas = document.getElementById('handOverlay');
        const overlayCtx = overlayCanvas.getContext('2d');

        // Match video size
        overlayCanvas.width = 400;
        overlayCanvas.height = 300;

        const cameraSetup = new Camera(videoElement, {
            onFrame: async () => {
                await hands.send({ image: videoElement });
            },
            width: 1280,
            height: 720
        });
        cameraSetup.start();
        
        // Helper function to convert hand coordinates
        function handToWorld(landmark) {
            return new THREE.Vector3(
                -(landmark.x - 0.5) * 12,
                -(landmark.y - 0.5) * 12,
                -landmark.z * 6
            );
        }
        
        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            
            const positions = particles.attributes.position.array;
            const colors = particles.attributes.color.array;
            
            // CONTROL PARAMETERS
            const influenceRadius = 5.0;
            const pushStrength = 0.8;
            
            // Update each particle
            for (let i = 0; i < particleCount; i++) {
                const i3 = i * 3;
                const particle = new THREE.Vector3(positions[i3], positions[i3 + 1], positions[i3 + 2]);
                
                // Apply forces from hands
                if (leftHand) {
                    const leftIndex = handToWorld(leftHand[8]);
                    const distToLeft = particle.distanceTo(leftIndex);
                    
                    if (distToLeft < influenceRadius) {
                        const strength = 1 - (distToLeft / influenceRadius);
                        
                        // ATTRACT particles toward hand (they follow it)
                        const direction = leftIndex.clone().sub(particle).normalize(); // Direction TO hand
                        const force = direction.multiplyScalar(pushStrength * strength * 0.5); // Gentler pull
                        velocities[i].add(force);
                    }
                }
                
                if (rightHand) {
                    const rightIndex = handToWorld(rightHand[8]);
                    const distToRight = particle.distanceTo(rightIndex);
                    
                    if (distToRight < influenceRadius) {
                        const strength = 1 - (distToRight / influenceRadius);
                        
                        // ATTRACT particles toward hand
                        const direction = rightIndex.clone().sub(particle).normalize();
                        const force = direction.multiplyScalar(pushStrength * strength * 0.5);
                        velocities[i].add(force);
                    }
                }
                
                // Special: Pull particles between hands when both are visible
                if (leftHand && rightHand) {
                    const leftIndex = handToWorld(leftHand[8]);
                    const rightIndex = handToWorld(rightHand[8]);
                    const handDistance = leftIndex.distanceTo(rightIndex);
                    
                    const midpoint = new THREE.Vector3().addVectors(leftIndex, rightIndex).multiplyScalar(0.5);
                    const distToMidpoint = particle.distanceTo(midpoint);
                    
                    if (distToMidpoint < handDistance * 0.5) {
                        const pullToLine = midpoint.clone().sub(particle).normalize().multiplyScalar(0.02);
                        velocities[i].add(pullToLine);
                    }
                }
                
                // Apply velocity
                positions[i3] += velocities[i].x;
                positions[i3 + 1] += velocities[i].y;
                positions[i3 + 2] += velocities[i].z;
                
                // Gentle pull back to center
                const centerPull = 0.0005;
                const distanceFromCenter = Math.sqrt(
                    positions[i3] * positions[i3] + 
                    positions[i3 + 1] * positions[i3 + 1] + 
                    positions[i3 + 2] * positions[i3 + 2]
                );
                
                if (distanceFromCenter > 0.1) {
                    velocities[i].x -= positions[i3] * centerPull;
                    velocities[i].y -= positions[i3 + 1] * centerPull;
                    velocities[i].z -= positions[i3 + 2] * centerPull;
                }
                
                // Add damping (friction)
                velocities[i].multiplyScalar(0.88);
                
                // Update colors based on velocity (speed)
                const speed = Math.sqrt(
                    velocities[i].x * velocities[i].x +
                    velocities[i].y * velocities[i].y +
                    velocities[i].z * velocities[i].z
                );

                const speedFactor = Math.min(speed * 5, 1);

                let baseR = 0.2;
                let baseG = 0.6;
                let baseB = 0.9;

                if (leftHand) {
                    const leftY = leftHand[8].y;

                    if (leftY < 0.33) {
                        // TOP = WARM (red to yellow)
                        const warmFactor = 1 - (leftY / 0.33);
                        baseR = 0.9 + warmFactor * 0.1;  // Red
                        baseG = 0.3 + warmFactor * 0.5;  // Orange/Yellow
                        baseB = 0.1;
                    } else if (leftY < 0.66) {
                        // MIDDLE = GREEN/CYAN
                        const midFactor = (leftY - 0.33) / 0.33;
                        baseR = 0.1;
                        baseG = 0.7 + midFactor * 0.2;
                        baseB = 0.5 + midFactor * 0.4;
                    } else {
                        // BOTTOM = COOL (blue to purple)
                        const coolFactor = (leftY - 0.66) / 0.34;
                        baseR = 0.2 + coolFactor * 0.6;  // Purple
                        baseG = 0.2;
                        baseB = 0.9;
                    }
                }

                colors[i3] = baseR + speedFactor * 0.3;
                colors[i3 + 1] = baseG + speedFactor * 0.3;
                colors[i3 + 2] = baseB;
            }
            
            // Update hand indicators
            /*if (leftHand) {
                const leftPos = handToWorld(leftHand[8]);
                leftIndicator.position.copy(leftPos);
                leftIndicator.visible = true;
                leftIndicator.rotation.x += 0.02;
                leftIndicator.rotation.y += 0.02;
            } else {
                leftIndicator.visible = false;
            }*/

            if (rightHand) {
                const rightPos = handToWorld(rightHand[8]);
                rightIndicator.position.copy(rightPos);
                rightIndicator.visible = true;
                rightIndicator.rotation.x += 0.02;
                rightIndicator.rotation.y += 0.02;
            } else {
                rightIndicator.visible = false;
            }

            // Update hand indicators
            if (leftHand) {
                const leftPos = handToWorld(leftHand[8]);
                leftIndicator.position.copy(leftPos);
                leftIndicator.visible = true;
                leftIndicator.rotation.x += 0.02;
                leftIndicator.rotation.y += 0.02;
            } else {
                leftIndicator.visible = false;
            }

            updateColorIndicator(); // ADD THIS LINE
            
            // Update liquid connections between particles
            const connectionDistance = 0.5;
            let connectionCount = 0;

            for (let i = 0; i < particleCount && connectionCount < maxConnections; i++) {
                const i3 = i * 3;
                const px = positions[i3];
                const py = positions[i3 + 1];
                const pz = positions[i3 + 2];
                
                for (let j = i + 1; j < particleCount && connectionCount < maxConnections; j++) {
                    const j3 = j * 3;
                    const dx = px - positions[j3];
                    const dy = py - positions[j3 + 1];
                    const dz = pz - positions[j3 + 2];
                    const distance = Math.sqrt(dx * dx + dy * dy + dz * dz);
                    
                    if (distance < connectionDistance) {
                        const lineIndex = connectionCount * 6;
                        linePositions[lineIndex] = px;
                        linePositions[lineIndex + 1] = py;
                        linePositions[lineIndex + 2] = pz;
                        linePositions[lineIndex + 3] = positions[j3];
                        linePositions[lineIndex + 4] = positions[j3 + 1];
                        linePositions[lineIndex + 5] = positions[j3 + 2];
                        connectionCount++;
                    }
                }
            }

            // Update all geometries ONCE at the end
            lineGeometry.setDrawRange(0, connectionCount * 2);
            lineGeometry.attributes.position.needsUpdate = true;
            particles.attributes.position.needsUpdate = true;
            particles.attributes.color.needsUpdate = true;
            
            renderer.render(scene, camera);
        }
        
        animate();
        
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
        // Toggle camera visibility for clean recording
        const toggleBtn = document.getElementById('toggleCamera');
        const video = document.getElementById('video');
        const overlay = document.getElementById('handOverlay');

        let cameraVisible = true;

        function toggleCamera() {
            cameraVisible = !cameraVisible;
            video.style.display = cameraVisible ? 'block' : 'none';
            overlay.style.display = cameraVisible ? 'block' : 'none';
            toggleBtn.textContent = cameraVisible ? 'Hide Camera [H]' : 'Show Camera [H]';
        }

        toggleBtn.addEventListener('click', toggleCamera);

        // Press 'H' key to toggle
        window.addEventListener('keydown', (e) => {
            if (e.key === 'h' || e.key === 'H') {
                toggleCamera();
            }
        });
        // Update color indicator position
        const colorMarker = document.getElementById('colorMarker');

        function updateColorIndicator() {
            if (leftHand) {
                const leftY = leftHand[8].y;
                const markerTop = 80 + (leftY * 200); // Map 0-1 to 80-280px
                colorMarker.style.top = markerTop + 'px';
                colorMarker.style.display = 'block';
            } else {
                colorMarker.style.display = 'none';
            }
        }
    </script>
</body>
</html>